Link,Comment,Weakness Category,Security Weakness
https://stackoverflow.com/a/20159305/5749570,"""+1 for the pd.read_clipboard(sep='\s\s+') tip. When I post SO questions that need a special but easily shared dataframe|| like this one I build it in excel|| copy it to my clipboard|| then instruct SOers to do the same. Saves so much time! """,Not A Weakness,No
https://stackoverflow.com/a/20159305/5749570,the pd.read_clipboard(sep='\s\s+') suggestion does not seem to work if you're using Python on a remote server|| which is where a lot of large data sets live.,Flaw,No
https://stackoverflow.com/a/20159305/5749570,Why pd.read_clipboard(sep='\s\s+')|| and not a simpler pd.read_clipboard() (with the default ‘s+’)? The first need at least 2 whitespace characters|| which may cause problems if there is only 1 (e. g. see such in the @JohnE 's answer).,Coding Error,No
https://stackoverflow.com/a/20159305/5749570,@MarianD the reason that \s\s+ is so popular is that there is often one e.g. in a column name|| but multiple is rarer|| and pandas output nicely puts in at least two between columns. Since this is just for toy/small datasets it's pretty powerful/majority of cases. Note: tabs separated would be a different story|| though stackoverflow replaces tabs with spaces|| but if you have a tsv then just use \t. ,Not A Weakness,No
https://stackoverflow.com/a/20159305/5749570,Ugh|| i always use pd.read_clipboard()|| when their are spaces|| i do: pd.read_clipboard(sep='\s+{2||}'|| engine='python') :P,Disagree,No
https://stackoverflow.com/a/20159305/5749570,I think it should be mentioned that df.head().to_dict() often produces a minimal representation of the dataset which can then be used to copy and paste code for the question. When it doesn't|| it's usually because there are too many columns. If there are too many columns|| a slice of the columns using df.columns[...] or df.select_dtypes will be very helpful.,Flaw,No
https://stackoverflow.com/a/17604212/5749570,"Or even d = ""cdef"" which leads to MyList = [""cdef""[k] for k in [x|| y|| z]]",Not A Weakness,No
https://stackoverflow.com/a/17604212/5749570,or map(lambda i: 'cdef'[i]|| [x|| y|| z]),Not A Weakness,No
https://stackoverflow.com/a/17604212/5749570,Aside from the list comprehension which I'm not yet fully accustomed to|| most of us had the same reflex: build that dict ! ,Not A Weakness,No
https://stackoverflow.com/a/31105868/5749570,Note that this code is recursive|| but recursion isn't necessary here|| and as Kevin said|| it can blow your stack.,Flaw,No
https://stackoverflow.com/a/31105868/5749570,"@PM2Ring - you are right. But my purpose here was just to show how ""short circuiting"" can minimise (beautify) long pieces of code. ",Not A Weakness,No
https://stackoverflow.com/a/31105868/5749570,Why would you assign a lambda to a variable|| just use def instead. def f(age): is far clearer than f = lambda age:,Disagree,No
https://stackoverflow.com/a/31105868/5749570,In some cases|| you may need the age just once and then there is no use of that function. One may want to use a function and throw it away after the job is done. Also|| this may not be the best way|| but it definitely is a different way of doing it (which was the purpose of my solution). ,Flaw,No
https://stackoverflow.com/a/31105868/5749570,@aaveg how would you turn this code to actually save the age provided by the user?,Not A Weakness,No
https://stackoverflow.com/a/31105868/5749570,"found it|| just return the age: f=lambda age: (age.isdigit() and (int(age)>=18  and age)) or \ f(input(""invalid input. Try again\nPlease enter your age: "")) print((input(""Please enter your age: "")))",Not A Weakness,No
https://stackoverflow.com/a/1373201/5749570,locals().update({'new_local_var':'some local value'}) works just fine for me in Python 3.7.6; so I'm not sure what you mean when you say you cannot assign values through it.,Disagree,No
https://stackoverflow.com/a/1373201/5749570,"Given x = ""foo"" and locals()[""x""] = ""bar"" using print x gives the output bar for Jython 2.5.2. This was tested with an On Demand Automation Script in maximo.",Not A Weakness,No
https://stackoverflow.com/a/1373201/5749570,"The documentation of locals() specifically says: ""The contents of this dictionary should not be modified."" (emphasis mine) ",Not A Weakness,No
https://stackoverflow.com/a/1373201/5749570,@JimDennis`locals()`` provides a dictionary created to represent local variables. Updating it does not guarantee to update the actual local variables. In modern Python implementations it's more like a picture (showing the content) in a nice frame (a high-level dict) – drawing on the picture won't actually change the real thing.,Disagree,No
https://stackoverflow.com/a/1373201/5749570,@JimDennis: You're likely using it in a context where it's not actually local variables of a function. In an actual function|| the real locals are not changed. Sure|| you can save off the result of locals() and read from/write to it|| but it never changes the real locals|| you're just getting a dict snapshot and modifying said dict. In the cases it works|| it's not actually locals (at least on CPython). ,Disagree,No
https://stackoverflow.com/a/1373201/5749570,The reason it doesn't work|| at least on CPython|| is that CPython allocates a fixed size array for locals|| and the size of said array is determined when the function is defined|| not when its run|| and can't be changed (access to true locals doesn't even use the name; the name is replaced with the index into the array at function compile time). locals() returns a true dict; within a function|| that dict is made by loading names and associated values in the array when you call locals()|| it won't see future changes. If it changes|| you're at global or class scope (which use dict scopes). ,Disagree,No
https://stackoverflow.com/a/509297/5749570,This suggestion works for positive stride|| but does not for a negative stride. From the diagram|| I expect a[-4||-6||-1] to be yP but it is ty. What always work is to think in characters or slots and use indexing as a half-open interval -- right-open if positive stride|| left-open if negative stride. ,Flaw,No
https://stackoverflow.com/a/509297/5749570,But there's no way to collapse to an empty set starting from the end (like x[:0] does when starting from the beginning)|| so you have to special-case small arrays. :/ ,Flaw,No
https://stackoverflow.com/a/509297/5749570,@aguadopd You are absolutely right. The solution is to have the indices shifted to the right|| centered just below the characters|| and notice that the stop is always excluded. See another response just below. ,Not A Weakness,No
https://stackoverflow.com/a/509297/5749570,Addendum to my comment: see my answer with diagrams below: stackoverflow.com/a/56332104/2343869,Not A Weakness,No
https://stackoverflow.com/a/240205/5749570,I am surprised that no body points out that|| the answer here is misleading. [x]*3 store 3 references like [x|| x|| x] is only right when x is mutable. This does't work for e.g. a=[4]*3|| where after a[0]=5|| a=[5||4||4].,Disagree,No
https://stackoverflow.com/a/240205/5749570,Technically|| it's still correct. [4]*3 is essentially equivalent to x = 4; [x|| x|| x]. It's true|| though|| that this will never cause any problem since 4 is immutable. Also|| your other example isn't really a different case. a = [x]*3; a[0] = 5 won't cause problems even if x is mutable|| since you're not modifying x|| only modifying a. I wouldn't describe my answer as misleading or incorrect - you just can't shoot yourself in the foot if you're dealing with immutable objects. ,Flaw,No
https://stackoverflow.com/a/240205/5749570,@Allanqunzi you are wrong. Do x = 1000; lst = [x]*2; lst[0] is lst[1] -> True. Python does not distinguish between mutable and immutable objects here whatsoever. ,Disagree,No
https://stackoverflow.com/a/240205/5749570,it's kinda late|| but is there a book where i can read about these subtleties of python?,Not A Weakness,No
https://stackoverflow.com/a/240205/5749570,can anyone find documents about the * operator in docs.python.org? i tried but cnanot find any. ,Not A Weakness,No
https://stackoverflow.com/a/240205/5749570,@LeiYang It's listed under Common Sequence Operations ,Not A Weakness,No
https://stackoverflow.com/a/1133255/5749570,How do you define a class attribute that is different for each instance of a class? ,Not A Weakness,No
https://stackoverflow.com/a/1133255/5749570,If it's different for each instance it's not a class attribute. Class attributes are attributes on the CLASS. Hence the name. Hence they are the same for all instances. ,Disagree,No
https://stackoverflow.com/a/1133255/5749570,How do you define an attribute in a class that is different for each instance of a class? (Re-defined for those who could not determine that a person not familiar with Python's naming convenctions might be asking about normal member variables of a class).,Disagree,No
https://stackoverflow.com/a/1133255/5749570,@Kievieli: You ARE talking about normal member variables of a class. :-) You define instance attributes by saying self.attribute = value in any method. For example __init__().,Not A Weakness,No
https://stackoverflow.com/a/1133255/5749570,@Kieveli: Two answers: you can't|| because any thing you define at a class level will be a class attribute|| and any instance that accesses that attribute will access the same class attribute; you can|| /sort of/|| by using propertys -- which are actually class level functions that act like normal attributes but save the attribute in the instance instead of the class (by using self.attribute = value as Lennart said).,Disagree,No
https://stackoverflow.com/a/2612815/5749570,As @Georgy points out correctly in the answer below|| any changes to the new_list values will also change the values in my_list. So actually the copy.deepcopy() method is the only real copy without reference to the original list and it's values. ,Not A Weakness,No
https://stackoverflow.com/a/2612815/5749570,You're right|| it was edited by you|| but posted by @cryo Sorry for the mixup! ,Not A Weakness,No
https://stackoverflow.com/a/2612815/5749570,Which one is fastest?,Not A Weakness,No
https://stackoverflow.com/a/2612815/5749570,I was having the same issue with a list of json (each element of a list was a json) and the only one that worked was new_list = copy.deepcopy(old_list) ; I'm writing this since anyone can encounter the same issue. Thanks! ,Not A Weakness,No
https://stackoverflow.com/a/2612815/5749570,"""+1 for slicing [:] it is a simple and compact syntax and it does make sense to use it every time you need to copy a list and can avoid a deepcopy""",Not A Weakness,No
https://stackoverflow.com/a/2612815/5749570,"""+4 for slicing [:] it is simple|| compact|| faster|| and more powerful: one can copy a slice of a list [start:stop]|| which other methods cannot do.""",Not A Weakness,No
https://stackoverflow.com/a/42773232/5749570,In my case I need to move those 'unwanted' elements into another list. Do you have any new comment about this solution? I also think that it is better to use some deletions instead of duplicate the list.,Not A Weakness,No
https://stackoverflow.com/a/42773232/5749570,This is the right answer if performance is an issue (although same as @Alexey). That said|| the choice of list as a data structure in the first place should be carefully considered since removal from the middle of a list takes linear time in the length of the list. If you don't really need random access to k-th sequential item|| maybe consider OrderedDict?,Not A Weakness,No
https://stackoverflow.com/a/42773232/5749570,@GVelascoh why not create newlist = []|| and then newlist.append(array[i]) just before del array[i]?,Disagree,No
https://stackoverflow.com/a/42773232/5749570,Note that this is likely time inefficient: if list() is a linked list|| the random access is expensive|| if list() is an array|| the deletes are expensive because they require to move all following elements forward. A decent iterator could make things good for the linked list implementation. This could however be space efficient. ,Flaw,No
https://stackoverflow.com/a/42773232/5749570,@CiroSantilli????????????? : The pop(i) operation is still O(n). I'll take storage efficiency over incremental improvements in O(n)|| but I can see why someone might do this differently.,Disagree,No
https://stackoverflow.com/a/20449433/5749570,Is there any other way|| like a function or something so that we dont need to convert to int in 3.x other than doing explicit conversion to int?? ,Not A Weakness,No
https://stackoverflow.com/a/20449433/5749570,@ShreyanMehta eval would work|| but don't go for that unless you have pressing reasons. ,Not A Weakness,No
https://stackoverflow.com/a/20449433/5749570,@thefourtheye at least use ast.literal_eval for that. It does not have the security concerns of eval,Obsolete,Yes